#!/usr/bin/perl

## amounts per level are 8, 64, 512, 4096, 32768
my $n = 4100; ## 33000;

srand(time());

my %hash;

my $content = '

#define GET 1
#define PUT 2
#define DEL 3
#define ITR 4

struct content { int action; int param; char* key; char* value; };

struct content content[] = {
';

my $i=0;
for (; $i<$n; $i++) {
  content_put();
  if (($i % 1000) == 0) {
    print STDERR "$i lines.\n";
  }
}
for (; $i < ($n*2); $i++) {
  if (($i % 1000) == 0) {
    print STDERR "$i lines.\n";
  }
  my $action = int(rand(8));
  if ($action == 0) {
    content_del();
  } elsif ($action == 1 || $action == 2) {
    content_put();
  } elsif ($action == 3) {
    content_iterate();
  } else {
    content_get();
  }
}
$content .= "  { 0, 0, 0, 0 }\n};\n";

sub content_put {
  my $occurence = rand(3);
  my $keysize = rand(20) + 3;
  my $key = '';
  for (my $k=0; $k<$keysize; $k++) {
    $key .= ( 'a' .. 'z', 'A' .. 'Z' )[ rand(52) ];
  }
  for (my $o=0; $o<$occurence; $o++) {
    my $valuesize = rand(60) + 20;
    my $value = '';
    for (my $v=0; $v<$valuesize; $v++) {
      $value .= ( 'a' .. 'z', 'A' .. 'Z' )[ rand(52) ];
    }
    $content .= "  { PUT, 0, \"$key\", \"$value\" },\n";
    my $exist = $hash{$key};
    push @{$exist}, $value;
    $hash{$key} = $exist;
  }
}

sub content_del {
  my @keys = keys(%hash);
  return if (!scalar(@keys));
  my $index = int(rand(scalar(@keys)));
  my $key = $keys[$index];
  my $nvalues = scalar(@{$hash{$key}});
  $content .= "  { DEL, $nvalues, \"$key\", NULL },\n";
  delete $hash{$key};
}

sub content_get {
  my @keys = keys(%hash);
  return if (!scalar(@keys));
  my $index = int(rand(scalar(@keys)));
  my $key = $keys[$index];
  my $nvalues = scalar(@{$hash{$key}});
  $content .= "  { GET, $nvalues, \"$key\", NULL },\n";
}

sub content_iterate {
  my @keys = keys(%hash);
  return if (!scalar(@keys));
  my $index = int(rand(scalar(@keys)));
  my $key = $keys[$index];
  my $nvalues = scalar(@{$hash{$key}});
  $content .= "  { ITR, $nvalues, \"$key\", NULL },\n";
}

print '#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "td_private.h"

/*
 * This file has been generated by hell.pl and tests the btree library.
 */

/*
extern int strcmp(char*,char*);
*/

'.$content.'

int main(int argc, char* argv[]) {
  td_t td;
  if (td_open(
        &td,
        "/tmp/foo",
    TDFLG_DUPLKEYS|TDFLG_EXTEND|TDFLG_CHECKSUM|TDFLG_SPARSE|TDFLG_WIPEDELETED,
        O_RDWR|O_CREAT|O_TRUNC,
        0664) == 0)
  {
    struct content* c = content;
    while (c->action) {
      switch (c->action) {
      case GET:
        {
          fprintf(stderr, "GET %s\n", c->key);
          char mem[128];
          memset(mem, 0, 128);
          tdt_t key = tdt_string(0, c->key);
          tdt_t val = { mem, 128 };
          int r = td_get(&td, &key, &val, 0);
          if (r) {
            fprintf(stderr, "Ended with error code %d\n", r);
            return ~0;
          }
          struct content* _c = content;
          int found = 0;
          while (_c->action) {
            if (_c->action == PUT &&
                _c->param == 1 &&
                !strcmp(_c->key, c->key) &&
                !strcmp(_c->value, mem))
            {
              found = 1;
              break;
            }
            _c++;
          }
          if (!found) {
            fprintf(stderr, "Could not find value; %-.*s\n",
              val.size, mem
            );
            return ~0;
          }
        }
        break;
      case PUT:
        {
          fprintf(stderr, "PUT %s -> %s\n", c->key, c->value);
          tdt_t key = tdt_string(0, c->key);
          tdt_t val = tdt_string(0, c->value);
          int r = td_put(&td, &key, &val, 0);
          if (r) {
            fprintf(stderr, "Ended with error code %d\n", r);
            return ~0;
          }
          c->param = 1;
        }
        break;
      case DEL:
        {
          int i=0; for (; i < c->param; i++) {
            fprintf(stderr, "DEL %s, %d\n", c->key, i);
            char mem[128];
            memset(mem, 0, 128);
            tdt_t key = tdt_string(0, c->key);
            tdt_t val = { mem, 128 };
            int r = td_del(&td, &key, &val, 0);
            if (r) {
              fprintf(stderr, "Ended with error code %d\n", r);
              td_debug(&td);
              return ~0;
            }
            struct content* _c = content;
            int found = 0;
            while (_c->action) {
              if (_c->action == PUT &&
                  _c->param == 1 &&
                  !strcmp(_c->key, c->key) &&
                  !strcmp(_c->value, mem))
              {
                _c->param = 0;
                found = 1;
                break;
              }
              _c++;
            }
            if (!found) {
              fprintf(stderr, "Could not find deleted value; \'%-.*s\'\n",
                val.size, mem
              );
              return ~0;
            }
          }
        }
        break;
      case ITR:
        {
          int r, i;
          tdt_t searchkey = tdt_string(0, c->key);
          tdc_t cursor;

          tdc_init(&td, &cursor);
          r = tdc_mov(&cursor, &searchkey, TDCFLG_EXACT);
          if (r) {
            fprintf(stderr, "Cursor move to %s went wrong.\n", c->key);
            return ~0;
          }
          fprintf(stderr, "ITR %s, expect %d instances\n", c->key, c->param);
          for (i=0; i < c->param; i++) {
            unsigned char keymem[ 128 ], valmem[ 128 ];
            tdt_t key = { keymem, sizeof(keymem) };
            tdt_t val = { valmem, sizeof(valmem) };

            if ((r = tdc_nxt(&cursor, &key, &val, 0)) != 0) {
              fprintf(stderr, "Cursor next error.\n");
              return ~0;
            }
            fprintf(stderr, "- ITR %-.*s, %d\n", key.size,(char*)(key.data),i);
            if (key.size < strlen(c->key)
                || strncmp(c->key, key.data, strlen(c->key)))
            {
              fprintf(stderr, "Cursor key %s does not match %-.*s.\n",
                              c->key, key.size, (char*)(key.data));
              return ~0;
            }
          }
        }
        break;
      }
      c++;
    }
    fprintf(stderr, "Deleting all that remains (%u).\n", td.header.nentries);
    {
      struct content* _c = content;
      while (_c->action) {
        if (_c->action == PUT && _c->param == 1) {
          char mem[128];
          memset(mem, 0, 128);
          tdt_t key = tdt_string(0, _c->key);
          tdt_t val = { mem, 128 };
          fprintf(stderr, "DEL %s\n", _c->key);
          int r = td_del(&td, &key, &val, 0);
          if (r) {
            fprintf(stderr, "Ended with error code %d\n", r);
            td_debug(&td);
            return ~0;
          }
        }
        _c++;
      }
    }
    if (td.header.nentries) {
      fprintf(stderr, "Btree should be empty now.\n");
      return ~0;
    }
  }
  return 0;
}
';
